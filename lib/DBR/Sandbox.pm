package DBR::Sandbox;

use strict;
use DBR;
use DBR::Util::Logger;
use DBR::Config::ScanDB;
use DBR::Config::SpecLoader;
use DBR::Config::Schema;
use DBR::Config::Instance::Anon;
use Scalar::Util 'blessed';
use File::Path;
use Carp;

sub import {
    my $pkg = shift;
    my %params = @_;
    my $dbr;

    my ($callpack, $callfile, $callline) = caller;

    if( $params{schema} ){
        DBR::Sandbox->provision( %params );
    }

}

my ($CONFDIR) = grep {-d $_ } ('schemas','example/schemas','../example/schemas');

sub provision{
    $| = 1;
    my $package = shift if blessed($_[0]) || $_[0] eq __PACKAGE__;
    my %params = @_;
    my $schema = $params{schema} or confess "schema is required";
    my $version = $params{version} || 1;
    
    my $sandbox = '_sandbox/' . $params{schema};
    my $dbrconf = $params{writeconf} || "$sandbox/DBR.conf";

    return if $params{reuse} && -e $dbrconf && -d $sandbox;

    print STDERR "Provisioning Sandbox... " unless $params{quiet};
    _ready_sandbox ( $sandbox );

    my $logger = new DBR::Util::Logger( -logpath => '_sandbox/sandbox_setup.log', -logLevel => 'debug3' ) or die "logger create failed";
    my $dbr = new DBR(
        -logger   => $logger,
        -noconf   => 1,
        -admin    => 1,
        -fudge_tz => 1,
    ) or die 'failed to create dbr object';
    my ($instance_factory, @factory_args) = split /,/, $ENV{DBR_SANDBOX_INSTANCE_FACTORY} || 'sqlite_factory';

    my $metadb = $package->$instance_factory('dbrconf', $sandbox, $dbr->session, @factory_args);
    my $maindb = $package->$instance_factory('db', $sandbox, $dbr->session, @factory_args);
    
    _load_sqlfile ( "$CONFDIR/dbr_schema_".lc($metadb->module)."_v$version.sql", $metadb );
    _load_sqlfile ( "$CONFDIR/$schema/sql", $maindb );
    
    $package->_setup_metadb( $sandbox, $schema, $metadb, $maindb );

    DBR->flush_handles;

    _write_dbrconf( $sandbox, $dbrconf, $version, $metadb );

    DBR::Config->new( session => $dbr->session )->load_file(
        dbr => $dbr, file => $dbrconf
    ) or die 'Failed to load DBR conf file';

    my $conf_instance = $dbr->get_instance('dbrconf') or die "No config found for confdb";
    my $scan_instance = $dbr->get_instance($schema)   or die "No config found for $schema";
    
    my $scanner = DBR::Config::ScanDB->new(
				     session => $dbr->session,
				     conf_instance => $conf_instance,
				     scan_instance => $scan_instance,
				    );
    
    $scanner->scan or die "Failed to scan $schema";
    
    my $loader = DBR::Config::SpecLoader->new(
                      session       => $dbr->session,
                      conf_instance => $conf_instance,
                      dbr           => $dbr,
                    ) or die "Failed to create spec loader";
    
    my $spec = $loader->parse_file( "$CONFDIR/$schema/spec" ) or die "Failed to open $CONFDIR/$schema/spec";

    $loader->process_spec( $spec ) or die "Failed to process spec data";

    print STDERR "Done. \n\n" unless $params{quiet};
    # returning DBR object to be used with test harnesses
    return $dbr;

}

sub _ready_sandbox{
    my $sandbox = shift;

    File::Path::rmtree( $sandbox ) if -e $sandbox;
    mkpath $sandbox or confess "failed to ready sandbox '$sandbox'";
}

sub _load_sqlfile{
    my $file = shift;
    my $inst = shift;
    my $conn = $inst->getconn;

    my $fh;
    open ($fh, "<$file") || return 0;
    my $buff;
    while (<$fh>){
      $buff .= $_;
    }

    foreach my $part (split(';',$buff)){
      next unless $part =~ /\S+/;
      next if $part =~ /^\s*--/;
      _run_metasql($inst, $part);
    }

    return 1;
}

sub _run_metasql {
    my ($inst, @sql) = @_;
    my $conn = $inst->getconn;
    my $sql = join '', @sql;

    local $conn->dbh->{RaiseError} = 1;
    $sql =~ s{TBL\((\w+)\)}{ $conn->table_ref($inst, $1) }eg;
    $sql =~ s{Q\((\w+)\)}{ $conn->quote_identifier($1) }eg;
    $sql =~ s/AUTOINCREMENT/AUTO_INCREMENT/g if $inst->module eq 'Mysql';
    $conn->dbh->do($sql);
}

sub _setup_metadb {
    my $self = shift;
    my $sandbox = shift;
    my $schema  = shift;
    my $dbr = shift;
    my $inst = shift;

    $dbr->connect->insert( -table => 'dbr_schemas', -fields => { schema_id => 1, handle => $schema } );

    $dbr->connect->insert(
        -table => 'dbr_instances',
        -fields => {
            schema_id => ['d',1],
            handle => $schema,
            class => 'master',
            module => $inst->module,
            dbfile => $inst->dbfile,
            host => $inst->host,
            username => $inst->username,
            password => $inst->password,
            dbname => $inst->database,
        }
    );

    return 1;
}

sub _write_dbrconf{
    my $sandbox = shift;
    my $dbrconf = shift;
    my $ver = shift;
    my $metadb = shift;

    my $fh;
    open ($fh, "> $dbrconf") or return 0;
    print $fh "# This DBR config file has been generated by the DBR::Sandbox library.\n";
    print $fh "# This conf file defines DB instances, at least one of which (dbrconf) is\n";
    print $fh "# required to have a starting point for fetching metadata. Defining other\n";
    print $fh "# instances here is possible, but discouraged, as functionality will be\n";
    print $fh "# dramatically degraded due to lack of metadata.\n\n";
    
    print $fh "name=dbrconf; class=master; database=@{[$metadb->database||'']}; dbfile=@{[$metadb->dbfile||'']}; type=@{[$metadb->module||'']}; host=@{[$metadb->host||'']}; user=@{[$metadb->username||'']}; password=@{[$metadb->password||'']}; dbr_bootstrap=1; meta_version=$ver\n";
    close $fh;

    return 1;
}

sub sqlite_factory {
    my ($pkg, $name, $sandbox, $sess, @args) = @_;

    return DBR::Config::Instance::Anon->new(
        session => $sess,
        dbfile  => "$sandbox/$name.sqlite",
        module  => "SQLite",
        prefix  => "",
        class   => "master",
    );
}

sub mysql_factory {
    my ($pkg, $name, $sandbox, $sess, $host, $user, $pass) = @_;

    my $inst = DBR::Config::Instance::Anon->new(
        session => $sess,
        module  => "Mysql",
        database => "dbr_sandbox_$name",
        user     => $user,
        password => $pass,
        hostname => $host,
        prefix  => "",
        class   => "master",
    );

    my $dbh = $inst->getconn->dbh;
    local $dbh->{RaiseError} = 1;
    $dbh->do('DROP DATABASE IF EXISTS '.$inst->database);
    $dbh->do('CREATE DATABASE '.$inst->database);
    return $inst;
}

1;
